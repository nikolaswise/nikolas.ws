/* generated by Svelte v3.24.0 */
import {
	SvelteComponent,
	detach,
	element,
	init,
	insert,
	noop,
	safe_not_equal,
	space
} from "svelte/internal";

function create_fragment(ctx) {
	let blockquote0;
	let t1;
	let blockquote1;
	let t3;
	let p2;
	let t5;
	let p3;
	let t7;
	let blockquote2;
	let t9;
	let p5;
	let t11;
	let blockquote3;
	let t13;
	let blockquote4;
	let t15;
	let p8;
	let t17;
	let p9;
	let t19;
	let blockquote5;
	let t21;
	let p11;
	let t23;
	let blockquote6;
	let t25;
	let p13;

	return {
		c() {
			blockquote0 = element("blockquote");
			blockquote0.innerHTML = `<p>Most interfaces in our world contain a blend of digital screens and analog inputs like switches and dials</p>`;
			t1 = space();
			blockquote1 = element("blockquote");

			blockquote1.innerHTML = `<p>How can we differentiate between the function of different inputs?
How can we organise the many inputs and outputs so that we understand how they relate to each other?</p>`;

			t3 = space();
			p2 = element("p");
			p2.textContent = "Designing interfaces is about wrapping with the above two questions, understanding relationships and functions. This applies for GUIs or CLIs, end user or developer experiences. Those are the two big human/machine questions.";
			t5 = space();
			p3 = element("p");
			p3.textContent = "Tools for differentiating include shape coding:";
			t7 = space();
			blockquote2 = element("blockquote");
			blockquote2.innerHTML = `<p>The right panel (“Aircraft Multiple Flight Controls”) clearly distinguishes between the throttle (large, linear vertical movement), toggle switches (round vertical flick) and the push buttons (square push-in).</p>`;
			t9 = space();
			p5 = element("p");
			p5.textContent = "Along with:";
			t11 = space();
			blockquote3 = element("blockquote");
			blockquote3.innerHTML = `<p>Colour coding is perhaps the only one to break into our everyday vocabulary, but we can add four more: size, texture, position and operation coding. Together these six are our allies in the design of error-proof interfaces.</p>`;
			t13 = space();
			blockquote4 = element("blockquote");
			blockquote4.innerHTML = `<p>Differentiation is a good first step that will avoid confusion between adjacent switches. But its only with organisation that we can create a clear and accurate mental model of the interface for the user.</p>`;
			t15 = space();
			p8 = element("p");
			p8.textContent = "Differentiation support organization.";
			t17 = space();
			p9 = element("p");
			p9.textContent = "Organizational techniques include distributed and consolidated:";
			t19 = space();
			blockquote5 = element("blockquote");
			blockquote5.innerHTML = `<p>These panels are what I’d called a consolidated interface. Every piece of input and feedback has been moved onto the same panel. This is the approach that Dyson took with their car. Now imagine the opposite, moving each of those lights and switches to the actual location of that valve in the factory. Sounds ludicrous, but these air vents in the Audi TT show that this distributed approach can also be a great win for user experience. I wrote a lot more about these distributed interfaces last year.</p>`;
			t21 = space();
			p11 = element("p");
			p11.textContent = "Feature based, operation based, technology based.";
			t23 = space();
			blockquote6 = element("blockquote");
			blockquote6.innerHTML = `<p>Any touchscreen with buttons by the side exhibits this technology-based split. In a future world, SpaceX might embed these physical controls right inside the screen next to the information they affect, but for now they sit awkwardly by the side as if nothing is wrong.</p>`;
			t25 = space();
			p13 = element("p");
			p13.textContent = "Technology based organization is not human centered, and therefor not ideal UX.";
		},
		m(target, anchor) {
			insert(target, blockquote0, anchor);
			insert(target, t1, anchor);
			insert(target, blockquote1, anchor);
			insert(target, t3, anchor);
			insert(target, p2, anchor);
			insert(target, t5, anchor);
			insert(target, p3, anchor);
			insert(target, t7, anchor);
			insert(target, blockquote2, anchor);
			insert(target, t9, anchor);
			insert(target, p5, anchor);
			insert(target, t11, anchor);
			insert(target, blockquote3, anchor);
			insert(target, t13, anchor);
			insert(target, blockquote4, anchor);
			insert(target, t15, anchor);
			insert(target, p8, anchor);
			insert(target, t17, anchor);
			insert(target, p9, anchor);
			insert(target, t19, anchor);
			insert(target, blockquote5, anchor);
			insert(target, t21, anchor);
			insert(target, p11, anchor);
			insert(target, t23, anchor);
			insert(target, blockquote6, anchor);
			insert(target, t25, anchor);
			insert(target, p13, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(blockquote0);
			if (detaching) detach(t1);
			if (detaching) detach(blockquote1);
			if (detaching) detach(t3);
			if (detaching) detach(p2);
			if (detaching) detach(t5);
			if (detaching) detach(p3);
			if (detaching) detach(t7);
			if (detaching) detach(blockquote2);
			if (detaching) detach(t9);
			if (detaching) detach(p5);
			if (detaching) detach(t11);
			if (detaching) detach(blockquote3);
			if (detaching) detach(t13);
			if (detaching) detach(blockquote4);
			if (detaching) detach(t15);
			if (detaching) detach(p8);
			if (detaching) detach(t17);
			if (detaching) detach(p9);
			if (detaching) detach(t19);
			if (detaching) detach(blockquote5);
			if (detaching) detach(t21);
			if (detaching) detach(p11);
			if (detaching) detach(t23);
			if (detaching) detach(blockquote6);
			if (detaching) detach(t25);
			if (detaching) detach(p13);
		}
	};
}

const metadata = {
	"title": "The UX of LEGO Interface Panels",
	"slug": "the-ux-of-lego-interface-panels",
	"author": "George Cave",
	"year": 2020,
	"source": "https://www.designedbycave.co.uk/2020/LEGO-Interface-UX/",
	"thesis": "Exploring user interface design via legos",
	"tags": "user experience",
	"date": "2020.08.24",
	"type": "annotation, bibliography"
};

const { title, slug, author, year, source, thesis, tags, date, type } = metadata;

class Component extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment, safe_not_equal, {});
	}
}

export default Component;
export { metadata };