{"data":{"fm":{"title":"The Shape of the Problem","slug":"shape-of-the-problem","date":"2021.06.29","description":"Ontological data structures, real-time editing, and what a web app _really_ is man.","type":"text","timestamp":1624950000000},"code":"<p>At <a href=\"https://smugmug.com\">work</a> the other day I was thinking about a problem: Websites as User Generated Content, a part of the business I've been low-key thinking about for nearly a year. A chance conversation with <a href=\"https://reubenson.com/\">Reuben Son</a> about Vox's content editing tool <a href=\"https://github.com/clay/clay-kiln\">Kiln</a> altered my perspective on who a <em>user</em> is when thinking about UGC. For them, their users are their editors and authors. Kiln works by loading an editor interface directly over the rendered web page, and allows for editing of any portion of that webpage.</p>\n<p>It occurred to me that one could use a real-time NoSQL database like <a href=\"https://fauna.com/\">FaunaDB</a> or <a href=\"https://firebase.google.com/\">Firebase</a> to store a document model, run an app that subscribes to changes to this database and renders the document model into the DOM, than do the same bit where a editor lays over the page and allows for editing, posting changes directly to the NoSQL database. The resulting update would re-render the document for the editor, <em>and anyone else also currently viewing the app</em>. This would look like Squarespace, but be naturally multi-tenant. After editing, a static site could be generated and hosted on s3 to serve to a larger audience. Questions around draft states, not publishing another users edits, and other logistical things started to crowd my mind, but the core idea was interesting enough for me to decide to put a prototype together.</p>\n<p>Unfortunately (well…) before I could get to it, I was dropped in cold to a meeting about an impending migration of our knowledge base. We have hundreds of articles with URLs that are going to get 100s of new URLs and we have to update them across out entire application, hopefully also solving the problem for good and never having to do it again. Since our larger content strategy was at the forefront of my mind, I pitched creating a Knowledge Organization System that associates a UUID with an article URL, then consume that UUID in applications and not worry about the URL. Front the whole thing with a content management system and our support team can update article URLs whenever and it's never a problem\nagain.</p>\n<p>Thats when I realized that <em>these two problems are the same problem</em>. Both have the same set of concerns and desired behaviors a collection of structured data documents that support CRUD operations, paired with a visualization of the. document. So:</p>\n<ul>\n<li>A collection of documents.</li>\n<li>A system for creation and editing of these documents.</li>\n<li>A web app for rendering and visualizing these documents, either in progress or some production state.</li>\n</ul>\n<p>Rephrased, the components are:</p>\n<ol>\n<li>The Ontology / Structure</li>\n<li>The Editor Interface</li>\n<li>The Rendered Form\\<br />\na. A Dynamic form<br />\nb. A Static form\\</li>\n</ol>\n<p>Note that the Dynamic form is not <em>necessarily</em> a server or client-side rendered experience, but a way of seeing the changes you're making before committing to a production state.  The Static form then is not <em>necessarily</em> a static asset (it can be server or client side generated from a database) but denotes a <em>stable production state</em> as viewed by a audience.</p>\n<p>For the knowledge base, the ontology is the index of articles. For the UGC websites, it is content and component structure. Thee editor interface is a CMS, either a product or like Kiln, something in house that sits on top. The rendered form for the sites is a static html build, for the knowledge base it's 301 redirect service.</p>\n<p>This is super abstract on purpose! I think this is the core structure of <em>all web apps</em>. Since this structure is so general as to be mostly useless (maybe interesting as a teaching tool),  the value of a <em>web app typology</em> must come from taking an opinionated perspective on all three of the above points. This can be used as a tool to examine and critique popular web app typologies to validate the concept; how does a given typology express its disposition and behaviors in each component?</p>\n<p>Our first typology for analysis is the &quot;Static Site&quot; – an unchanging directory of html files generated at build time from a codebase, largely on a developers local machine. The ontology of many popular static site generates is the local file system, and attendant metadata. The editor interface is the developers command line and the source code repository (git really is an excellent content management system). The dynamic form is a dev server that runs locally and re-renders changes in real-time, and the static form is the built source code output to static assets.</p>\n<p>Another popular typology is the &quot;Wordpress Site&quot;. A <a href=\"/wordpress-but-not-terriible\">classic in web development</a>. Here, the ontology is a MySQL database who's structure is invented ad-hoc by the developer. The editor interface is a PHP (and React I guess with Wordpress 5) web application that allows for manipulation of the MySQL database. The dynamic form is the &quot;preview&quot; of database changes or a &quot;staging&quot; environment for code and data, whole the static form is determined by PHP templates that fetch data form the database and interpolate pages at run time, on each request.</p>\n<p>The &quot;Shopify&quot; is structurally the same as the &quot;Wordpress&quot;, but swap PHP for Ruby like a good early 2000's startup and make the  Ontology a pre-determined e-commerce structure. I think this is the dominant web app disposition, with a range of opinions on how much should happen on the server and how much should happen on the client.</p>\n<p>Two other typologies I think are worth exploring, the &quot;Notebook&quot; and the &quot;Data Driven Web App&quot;. The Notebook, like <a href=\"https://observablehq.com/\">Observable</a> positions the ontology as an unstructured document. The editor interface is a word processor app for that document, and the rendered form is a combination of pre-set app framework and <em>the contents of the document</em>. Dynamic form is a draft state of the document, static form is a published state. Notebooks are very interesting and different, and Observable is a great example of one. Since we're in the neighborhood of Mike Bostock, let's talk about &quot;Data Driven Applications&quot;. The ontology <em>is the data doing the driving</em>. The rendered form is source code for visualizing the data — dynamic locally run while editing code, static is hosted on a server or cdn. The editor interface is relinquished to whatever real-world process governs the collection of the data.</p>\n<p>Each typology is a powerful conception of what a web app can be, and each one has a unique and distinct perspective on the three important parts of what a web app is. No one is better than the others, since they each have a different relationship. And a different definition of good.</p>\n<p>The shape of my two problems that were actually one problem gave me an idea for a new kind of web app typology, one that borrows from the Semantic Web and real-time web apps. The dispositions and technical behavior of the app would look something like this:</p>\n<h2>1: The Ontology</h2>\n<p>This kind of app will use off-the-shelf RFDA or JSON-LD ontologies. These ontologies can be extended or created, but <em>must</em> be valid RDFA or JSON-LD (either is fine, since they can be machine translated into each other). This allows for deeply semantic structures, machine readable relationships, and lossless data transfer between systems. Structuring this data as a graph allows for narrow, tailored <em>consumption</em> of the dat via GraphQL without dedicated API development and maintenance. It also allows for the entire data system to be visualized.</p>\n<p>Using these semantic ontologies rather than providing a blank slate and letting the data structures grow on an ad-hoc basis also saves <em>a lot</em> of time in creating the data models; since it's all semantic and robot friendly a single URI to the ontology should be enough to populate all the content models any given editor interface might need.</p>\n<h2>2: The Rendered Form</h2>\n<p>The guiding principle of thee rendered form is to be as light as possible over the wire, for both the dynamic and static forms.</p>\n<p>The rendered form splits the difference between a JAMstack real-time application and a static site. The dynamic form is hosted as a web app, and subscribes to real-time changes in the ontology documents. As the data changes, the dynamic form updates to reflect it. This takes the development build off of the local machine and puts it where more than one person can see it at a time. The static form is a built collection of static html files that an be hosted from any CDN to the wider audience.</p>\n<h2>3: The Editor Interface</h2>\n<p>The editor is completely separate from the renderer, but a common protocol unites it with the renderer on one end and the ontology on the other. Load the editor on any given dynamic rendered page to get an experience where <em>any</em> given property of the ontology can be edited, written to the database, and the effects seen immediately in real-time by anyone connected to the dynamic render. The diffs can then be stashed, discarded, or published.</p>\n<h2>Conclusion</h2>\n<p>The end result of an app like this would be an experience sort of like <a href=\"https://glitch.com/\">Glitch</a>, sort of like <a href=\"https://www.squarespace.com/\">Squarespace</a> and sort of like <a href=\"https://observablehq.com/\">Observable</a>.</p>\n<p>With permissions around what rendering or editing app can see or touch what in the database, its possible and even <em>important</em> that any given concept that relates to the system can be represented in the system — either the data itself of a metadata record that is indexical to the data. This allows the entire system to be meaningfully connected, which enables solutions for many common problems (uri mapping, incompatable data structures, duplicated databases, nightmare migrations, vendor lock in) and opens the door to new use cases and implementations, like bespoke CRMs seamlessly integrated into a product or an ecosystem of <em>editing experiences</em> that are completely independant of any given renderer or ontology.</p>\n<p>A clumsy handle for this kind of app could be a Semantic Mono-Database. Not as catchy as JAMstack, SPA, or Static Site. We'll get there tho, I'm sure a meaningful name will present itself as I work to build the first real one of these things.</p>\n"}}