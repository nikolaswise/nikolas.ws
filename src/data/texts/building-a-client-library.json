{"meta":{"title":"Building a Client Library for ArcGIS","slug":"building-a-client-library","date":"2015.3.09","description":"<p>Writing a wrapper client library to smooth out design weirdness at the API level leads to plenty of design thinking on the way things should be.</p>\n","collection":"texts","timestamp":1425884400000},"content":"<p>This year I built a JavaScript wrapper for Node and the Browser around the ArcGIS REST API to simplify working with that platform as a developer. This was as an exercise in API design, as well as making a tool that I wanted to use but didn't exist yet. The project is a bare-bones library to ease interactions with the ArcGIS REST API in JavaScript and Node apps.</p>\n<p>Sometimes – and for sure in this case – an API can be rough, built over time, and not provide the sort of logical models that work well with specific language environments. This was the case with the ArcGIS REST API that I was running in to. A lot of the decisions had been made over the course of years, and didn't translate very smoothly a language as young as Node.js.</p>\n<p>The first step was to figure out what problems I wanted to solve. A lot of my work with Esri PDX has been about content handling, and so this is where I started. Reading <em>all</em> the doc to get a big picture of what's going on with the API, and talk to everyone who's done work like this before to figure out what problems <em>they</em> needed to solve was the first step. From there I felt I had enough context and information to make the thing useful for more people than just me, and make sure that it was coherent with the underlying goals of the original API.</p>\n<p>This project works to simplify and unify the gap between the ArcGIS REST API and a contemporary Node application. This library is a UI in the most basic sense of the term — it provides an interface between the developer and the servers. That interface needs to be well designed and thoughtful in order to make the process as smooth, intuitive, and pleasurable as possible.</p>\n<p>One of the most important parts of the project is to provide developers with a way to access the ArcGIS platform without needing to architect their entire application around opinionated frameworks (like Dojo, for example). Though the library itself is written in ES6, it's distributed as plain, normal ES5 – both as a node package and a packaged bundle. This means it works both in Node and the browser, and has very few opinions on how it integrates with the rest of your app.</p>\n<p>Right now, the library wraps most of the basic platform content management and interactions - getting and editing users, organizations, and items. The Node ArcGIS Client Library is an open source project — so it's scope will increase as the community works to accomplish more goals and workflows.</p>\n<h2>Setting up the client</h2>\n<p>The first step in using the library is initializing the client with your target portal.</p>\n<pre><code><span class=\"hljs-variable\">var</span> <span class=\"hljs-variable\">ArcGIS</span> = <span class=\"hljs-function\"><span class=\"hljs-title\">require</span>(<span class=\"hljs-string\">&#x27;arcgis&#x27;</span>)</span>\n<span class=\"hljs-variable\">var</span> <span class=\"hljs-variable\">arcgis</span> = <span class=\"hljs-function\"><span class=\"hljs-title\">ArcGIS</span>()</span>\n</code></pre>\n<p>This sets up a default object for interacting with the API. This default is going to talk to ArcGIS Online as an anonymous, unauthenticated user. One can authenticate this client session as a named user by passing in a user token obtained from a successful OAuth login process.</p>\n<pre><code><span class=\"hljs-variable\">var</span> <span class=\"hljs-variable\">arcgis</span> = <span class=\"hljs-function\"><span class=\"hljs-title\">Arcgis</span>({\n  <span class=\"hljs-variable\">token</span>: <span class=\"hljs-variable\">namedUserToken</span>\n})</span>\n</code></pre>\n<p>This isn't exclusive to ArcGIS Online. The API for interacting with your organization's installation of Portal or Server is the same. Setting up the client session with your instance is done by specifying your API domain.</p>\n<pre><code><span class=\"hljs-attr\">var</span> <span class=\"hljs-string\">arcgis = Arcgis({</span>\n  <span class=\"hljs-attr\">domain</span>: <span class=\"hljs-string\">&#x27;ago.my-server.com&#x27;,</span>\n  <span class=\"hljs-attr\">token</span>: <span class=\"hljs-string\">namedUserToken</span>\n<span class=\"hljs-attr\">})</span>\n</code></pre>\n<p>Beyond the initialization of the client, the library is exclusively async. All the functions return promises by default.</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">log</span> (<span class=\"hljs-params\">m</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(m)\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ohNo</span> (<span class=\"hljs-params\">err</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(err)\n}\narcgis.request()\n.then(log)\n.catch(ohNo)\n</code></pre>\n<p>You can also pass in a node-style callback, if you'd prefer.</p>\n<pre><code><span class=\"hljs-keyword\">function</span> <span class=\"hljs-built_in\">log</span> (<span class=\"hljs-built_in\">err</span>, results) {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">err</span>) {\n    return <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">Error</span>(<span class=\"hljs-built_in\">err</span>)\n  } <span class=\"hljs-keyword\">else</span> {\n    console.<span class=\"hljs-built_in\">log</span>(results)\n  }\n}\narcgis.<span class=\"hljs-built_in\">request</span>({}, <span class=\"hljs-built_in\">log</span>)\n</code></pre>\n<p>Both methods work just as well, and use all the same business logic. I like promises, but maybe you don't. This is one of the main reasons the library does its best to avoid inflicting my opinions on your codebase.</p>\n<p>Once we have an authenticated session, we can do all sorts of stuff — like figure out who we are:</p>\n<pre><code><span class=\"hljs-keyword\">function</span> hello (<span class=\"hljs-keyword\">user</span>) {\n  console.log(<span class=\"hljs-string\">&#x27;Hello, &#x27;</span> + <span class=\"hljs-keyword\">user</span>.firstName)\n}\narcgis.<span class=\"hljs-keyword\">user</span>(<span class=\"hljs-string\">&#x27;NikolasWise&#x27;</span>).<span class=\"hljs-keyword\">then</span>(hello)\n</code></pre>\n<p>We can get all of the items that user has in the platform:</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getContent</span> (<span class=\"hljs-params\">user</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> user.content()\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">logContent</span> (<span class=\"hljs-params\">content</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(content)\n}\narcgis.user(<span class=\"hljs-string\">&#x27;NikolasWise&#x27;</span>)\n.then(getContent)\n.then(logContent)\n</code></pre>\n<p>Or a list of all the groups that a user is a member of.</p>\n<pre><code><span class=\"hljs-keyword\">function</span> logGroups (item) {\n  item.<span class=\"hljs-keyword\">groups</span>.<span class=\"hljs-keyword\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-keyword\">group</span>) {\n    console.log(<span class=\"hljs-keyword\">group</span>.title)\n  })\n}\narcgis.<span class=\"hljs-keyword\">user</span>(<span class=\"hljs-string\">&#x27;NikolasWise&#x27;</span>).<span class=\"hljs-keyword\">then</span>(logGroups)\n</code></pre>\n<p>The library also can interact with the user's organization, returning information, members, or all the content associated with the organization.</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">logOrg</span> <span class=\"hljs-params\">(org)</span> <span class=\"hljs-comment\">{\n  console.log(org)\n}</span>\n<span class=\"hljs-title\">arcgis</span>.<span class=\"hljs-title\">organization</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&#x27;esripdx&#x27;</span>)</span>.<span class=\"hljs-title\">then</span><span class=\"hljs-params\">(logOrg)</span>\n</span></code></pre>\n<p>The organization call defaults to 'self' — whatever organization the current user is a member of.</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getMembers</span> <span class=\"hljs-params\">(org)</span></span> {\n  <span class=\"hljs-keyword\">return</span> org.members()\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">log</span> <span class=\"hljs-params\">(members)</span></span> {\n  console.<span class=\"hljs-built_in\">log</span>(members)\n}\narcgis.organization().<span class=\"hljs-keyword\">then</span>(getMembers).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-built_in\">log</span>)\n</code></pre>\n<p>Many of the content calls are abstractions or helper methods for longer, more complicated calls to the <code>search</code> endpoint.</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getContent</span> <span class=\"hljs-params\">(org)</span></span> {\n  <span class=\"hljs-keyword\">return</span> org.content()\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">log</span> <span class=\"hljs-params\">(items)</span></span> {\n  console.<span class=\"hljs-built_in\">log</span>(items)\n}\narcgis.organization().<span class=\"hljs-keyword\">then</span>(getContent).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-built_in\">log</span>)\n</code></pre>\n<p>In this way we are able to create a transitional layer between the API itself (a super complicated call to the search endpoint) and what application developers need (all my organization's content).</p>\n<h2>Working with content</h2>\n<p>Platform content is the weakest link in the library as of today. ArcGIS supports a huge range of item types, and quite a number of sophisticated things you can do with those item types. For now the basics are more or less in place — like getting an item's details:</p>\n<pre><code><span class=\"hljs-keyword\">var</span> layerID = <span class=\"hljs-string\">&#x27;a5e5e5ac3cfc44dfa8e90b92cd7289fb&#x27;</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">logItem</span> <span class=\"hljs-params\">(item)</span> <span class=\"hljs-comment\">{\n  console.log(item)\n}</span>\n<span class=\"hljs-title\">arcgis</span>.<span class=\"hljs-title\">item</span><span class=\"hljs-params\">(layerID)</span>.<span class=\"hljs-title\">then</span><span class=\"hljs-params\">(logItem)</span>\n</span></code></pre>\n<p>Or updating the those details and editing the permissions:</p>\n<pre><code>var layerId = <span class=\"hljs-symbol\">&#x27;a5e5e5ac3cfc44dfa8e90b92cd7289fb</span>&#x27;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">updateItem</span> (item) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">item.update({</span>\n    snippet: <span class=\"hljs-symbol\">&#x27;Building</span> footprints <span class=\"hljs-keyword\">in</span> my neighborhood <span class=\"hljs-keyword\">in</span> Portland, Oregon&#x27;\n  })\n}\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">shareItem</span> (item) {\n  console.log(item)\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">item.permissions({</span>\n    <span class=\"hljs-keyword\">access</span>: <span class=\"hljs-symbol\">&#x27;public</span>&#x27;\n  })\n}\narcgis.item(layerId)\n.<span class=\"hljs-keyword\">then</span>(updateItem)\n.<span class=\"hljs-keyword\">then</span>(shareItem)\n</code></pre>\n<p>So far, there's some support for item-type-specific methods that are starting to open up the possibilities of manipulating your content from Node — like getting all the data in a layer.</p>\n<pre><code><span class=\"hljs-keyword\">var</span> layerID = <span class=\"hljs-string\">&#x27;a5e5e5ac3cfc44dfa8e90b92cd7289fb&#x27;</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getData</span> (<span class=\"hljs-params\">item</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> item.data()\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">logData</span> (<span class=\"hljs-params\">data</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(data)\n}\narcgis.item(layerId)\n.then(getData)\n.then(logData)\n</code></pre>\n<p>There is a lot more of the platform that we could cover than this - services, analysis, layer creation and tile publishing all are actions that this library or ones like it could cover.</p>\n"}