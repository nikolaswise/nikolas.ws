{"data":{"fm":{"title":"Pressing Words, With Your Friend, Wordpress","slug":"wordpress-but-not-terrible","date":"2018.10.24","description":"A contemporary developers guide to building things on Wordpress 4.x and not having it be terrible.","type":"text, texts","timestamp":1540364400000},"code":"<p>TL:DR; <a href=\"https://github.com/nikolaswise/nanobox-wordpress-1\">Start here</a>. Install <a href=\"https://nanobox.io/\">this thing</a> and connect it to your account on <a href=\"https://www.digitalocean.com/\">here</a>. Buy a license of <a href=\"https://deliciousbrains.com/wp-migrate-db-pro/\">this (it's worth it)</a>. Read some docs for <a href=\"https://www.upstatement.com/timber/\">this</a> and start building. Wordpress 5 and Gutenberg will probably break all of this except the environments.</p>\n<p>When I first started working as a developer, Wordpress was <em>the</em> prevalent platform for pretty much any project. Ten years later and ‚Ä¶ Wordpress is still pretty much most of the internet. In general, Wordpress will be my last choice of a platform. I prefer to build static sites, use a headless CMS, or almost anything else at all.</p>\n<p>That said, as the Technical Director at Fuzzco ‚Äî a design studio that relies almost exclusively on Wordpress for their websites ‚Äî Wordpress was happening. Fuzzco is rare among studios in that we manage and host projects for our clients, and often have maintenance riders that can last for years. This means that in the course of a year, not only did we build a half dozen new projects on Wordpress, but we maintained and triaged issues on over 100 legacy projects.</p>\n<p>Very quickly I realized I had one option: <em>make Wordpress not terrible.</em></p>\n<h2>Terrible is pretty harsh</h2>\n<p>If you're comfortable with Wordpress, you might find some fightin' words here. What's my problem with Wordpress and what am I trying to solve for? My biggest issue with Wordpress development as I've encountered it in the past is a lack of clarity around the requirements of the entire system. What does the project need to run in an environment, and why? How do we move from a repository to a local environment and start working on a codebase? How does that codebase get deployed to a server?</p>\n<p>I've seen Wordpress systems that are frozen in time in 2006 ‚Äî FTP to the server and edit a CSS file on production, or &quot;deploy&quot; your theme by uploading a <code>.zip</code>. I'm interested in how we can lower the cognitive overhead for getting a Wordpress project up and running, and join in with pre-processing, compiling, containerizing, testing, and all the really excellent things that we've come to expect from our web stacks over the past few years.</p>\n<p>Another issue I have with Wordpress is its commitment to auto-magical routes and rendering templates with obscure and complicated <code>.php</code> patterns that basically concatenate strings. I'm interested in explicit routes ‚Äî either hard-coded or parameterized ‚Äî and separating concerns between logic and template.</p>\n<p>A lot of this boils down to a disagreement between what Wordpress thinks a site should be and what I end up using it for. Wordpress as designed distinguishes between your &quot;site&quot; and your &quot;theme&quot;. Your &quot;site&quot; is the content in the database, the options you've saved, and the menus and widgets you've installed. It expects &quot;themes&quot; to be presentations of this real website stuff. This model of websites perpetuates that &quot;design&quot; is something that can be applied over a website, a kind of dressing up of the real things. This is the inverse, and perhaps a corollary to, the concept that designing a website is just deciding what it looks like. It's an idea that lives within the system of silos between design and development, and that we can &quot;design&quot; a website in Photoshop or Sketch and hand off the comps to a developer to build it. Which is how a lot of Wordpress projects are built.</p>\n<p>In short, <a href=\"/texts/how-to-design-while-developing/\">I disagree</a> with this concept of websites. My position is that designing a website is both how it looks, how it works, and how the data and structures are composed. Taking this approach, controlling the object models, the information architectures, and the templates are all of equal importance. In my line of work, a Wordpress theme can not be applied to any other site than the one that it was designed for, a site where the structure was designed for the theme.</p>\n<h2>So why use Wordpress?</h2>\n<p>There are still a number of really good, compelling reasons to use Wordpress as a platform for building websites. It's got a robust built-in commenting system with user accounts. It's really good for things that are shaped like blogs. It's got a huge, well-maintained ecosystem of plugins. It's free. And since it's most of the Internet, clients are really, really comfortable with it.</p>\n<p>There are a couple of reasons <em>not</em> to use Wordpress right now. Mostly these center around the impending release of Wordpress 5.0 and the Gutenberg editor, which has a number of concerns around plugin compatibility and accessibility for authors.</p>\n<p>But that's okay, since we've decided to use Wordpress 4.x. As we all know, picking a version of Wordpress and then never upgrading it is one of the time honored traditions of Wordpress development.</p>\n<h2>How does this work even</h2>\n<p>Let's start at the end.</p>\n<p>We're going to be hosting our production Wordpress site on a <a href=\"https://www.digitalocean.com/\">Digital Ocean</a> droplet ‚Äî the <a href=\"https://www.digitalocean.com/pricing/\">smallest</a> one they have ‚Äî for $5 per month. Depending on the project lifecycle, we can set up more droplets for a staging server and a development server. At Fuzzco we used dev servers to show sites to the internal team, staging servers to show sites to the client, and production servers to show sites to the public.</p>\n<p>I don't know about you, but I personally don't super love managing my virtual private servers manually. In order to deploy our codebases to Digital Ocean we'll use the phenomenal tool <a href=\"https://nanobox.io/\">Nanobox</a>. Nanobox is an operations layer that handles containerizing applications and deploying them agnostically to a cloud service provider. Nanobox will deploy our code from the command line to any one of our droplets.</p>\n<p>Nanobox will also containerize and run an application in a virtual machine <em>locally</em>. This means we'll use it to run our development environment, and ensure that all of our environments are identical. No more worrying about PHP versions and extensions and plugins. No more running MAMP or MySQL or Apache or whatever on your local machine before anything works. Nanobox defines the server in a <code>.yaml</code> file, and it will always be the same. It also handles all the syncing between our local disk and our virtual environment.</p>\n<p>So now that we know how our code is going from local to production, we can think for a second about <em>how</em> it's going to do that, and how we're going to manage our data.</p>\n<p>The database on the production server is &quot;canonical&quot;. That means that the database the client interacts with is the one true database, and we must treat it with care and attention. We'll never change that database ourselves, and we'll move that database <em>downstream</em> from production to staging to dev to local in order to develop against our real data. Importantly, we don't want to migrate the database manually either. It's a little expensive but using <a href=\"https://deliciousbrains.com/wp-migrate-db-pro/pricing/\">Migrate DB Pro</a> is an incredible resource for this part. I guess one could also look into <a href=\"https://github.com/wp-sync-db/wp-sync-db\">alternatives</a> for personal projects.</p>\n<p>The canonical <em>codebase</em> lives in version control, and moves the other direction. From Github to local to dev to staging to production, amen. The only things we need to track in version control are what makes our project unique. Practically, this means we need to track our theme and our plugins. Wordpress core files are not special, and we should not fill our repositories with them.</p>\n<h2>Getting started</h2>\n<p>At this point it's worth <a href=\"https://docs.nanobox.io/install/\">getting started with Nanobox</a>. I back the containers with <a href=\"https://docs.nanobox.io/install/#lightweight-vm-virtualbox\">VirtualBox</a>, since at the time I started this it was slightly more stable than Docker on MacOS High Sierra. Once Nanobox &amp; Virtualbox/Docker is installed, set up <a href=\"https://docs.nanobox.io/providers/hosting-accounts/digitalocean/\">Digital Ocean as your provider</a>. Once that's done, we have everything we need to get started!</p>\n<p>I'll be talking through a project I built in order to facilitate building other projects. This will be more intense than you might need for a single build, but this was designed a tool that anyone can use to get started quickly. Here's the basic structure of our repo:</p>\n<pre><code>üìÅ /project-name\n‚Æë üìÑ .gitignore    # includes /wp\n‚Æë üìÑ package.json  # tooling lives here\n‚Æë üìÑ readme.md     # be nice, write docs    \n‚Æë üìÅ theme         # our theme codebase\n‚Æë üìÅ plugins       # vendor plugins\n‚Æë üìÅ scripts       # some helpers\n</code></pre>\n<p>The crux of the project is our <code>boxfile.yml</code> configuration file. This is what Nanobox uses to create our containers. It looks like this!</p>\n<pre><code># /boxfile.yml                \nrun.config:                    # \n  engine: php                  #\n  engine.config:               #\n    runtime: php-7.0           # Defines PHP version\n    document_root: 'wp/'       # Dir to serve app from\n    extensions:                # PHP extensions we need\n      - gd                     #\n      - mysqli                 #\n      - curl                   #\n      - zlib                   #\n      - ctype                  #\n                               #\nweb.wp:                        #\n  start: php-server            #\n  network_dirs:                #\n    data.storage:              #\n      - wp/wp-content/uploads/ #\ndata.db:                       #\n  image: nanobox/mysql:5.6     # Nanobox DB magic\n                               #\ndata.storage:                  #\n  image: nanobox/unfs:0.9      #\n</code></pre>\n<p>As noted above, we'll be serving our entire installation of Wordpress in the <code>/wp</code> directory. This will hold all the Wordpress core files and compiled theme code, none of of which we need or want in version control. As such, make sure this is listed alongside <code>node_modules</code> in the <code>.gitignore</code>.</p>\n<p>Since we've decided that we don't want to track these files, but we need them to actually have a project, we can write a helper script to take care of the gap between those two ideas.</p>\n<p>Here are the scripts we're going to write to help us handle this process:</p>\n<pre><code>üìÅ /project-name\n‚Æë üìÅ scripts\n   ‚Æë üìÑ check-install.sh # Installs Wordpress core files.\n   ‚Æë üìÑ init.sh          # Runs our setup helper.\n   ‚Æë üìÑ prestart.sh      # Checks if we need to init.\n   ‚Æë üìÑ setup.js         # Cute lil' CLI helper.\n</code></pre>\n<p>The first thing we'll do is write a script that checks if <code>/wp</code> exists. If it doesn't, throw an error that we need to initialize the project since we don't have any of the core files we need.</p>\n<pre><code># prestart.sh\n#!/bin/bash\necho 'Check to make sure wordpress is here at all'\nif test -d ./wp/\nthen\n  echo 'yup we good'\n  exit 0\nelse\n  echo 'Project not initialized: Run `$ npm run init`'\n  exit 1\nfi\n</code></pre>\n<p>I'm calling this <code>prestart</code> because I want to run it before <code>npm start</code>. Many times I'll be on autopilot, and after cloning a repo simply run <code>npm install</code> and <code>npm start</code>. This interrupts that process and lets me know I need a third step, <code>npm run init</code>. Let's put this in our <code>package.json</code> scripts:</p>\n<pre><code># package.json\n{\n  ...\n  &quot;scripts&quot;: {\n    ...\n    &quot;init&quot;: &quot;./scripts/init.sh&quot;,\n    &quot;prestart&quot;: &quot;./scripts/prestart.sh&quot;,\n    &quot;start&quot;: &quot;npm run dev&quot;\n  }\n  ...\n}\n</code></pre>\n<p>We'll get to our dev tooling later. Lets take a look at what our <code>init.sh</code> script does:</p>\n<pre><code># init.sh\n#!/bin/bash\nnode ./scripts/setup.js  \n</code></pre>\n<p>Not much! This just runs our setup CLI helper. You might not need all this, but since I built this system to help a team of developers work on <em>many many</em> projects you're gonna get it anyway.</p>\n<pre><code>// setup.js\n\n// some nice deps for making a CLI.\nconst prompt = require('prompt')\nconst exec = require('child_process').exec\nconst colors = require(&quot;colors/safe&quot;)\n\n// Run and log a bash command\nconst bash = cmd =&gt; {\n  msg('green', `Running: ${cmd}`)\n  return new Promise(function(resolve, reject) {\n    exec(cmd, (err, stdout, stderr) =&gt; {\n      if (err) reject(err)\n      resolve(stdout, stderr)\n    })\n  });\n}\n\n// Log a message\nconst msg = (color, text) =&gt; {\n  console.log(colors[color](text))\n}\n\n// do the magic\nconst setup = (err, result) =&gt; {\n  if (err) msg(`red`, err)\n\n  msg('yellow', 'WordPress configuration values ‚òü')\n\n  for (let key in result) {\n    msg('yellow', `${key}: ${result[key]};`)\n  }\n  // run our check-install script.\n  bash(`${process.cwd()}/scripts/check-install.sh`)\n  .then(ok =&gt; {\n    // add our project to hostfile\n    bash(`nanobox dns add local ${result.name}.local`)\n  })\n  .then(ok =&gt; {\n    // explain the next step\n    msg('green', `Run npm start, then finish setting up WordPress at ${result.name}.local/wp-admin`)\n  })\n}\n\nmsg('green', 'Making Progress!')\nprompt.start();\nprompt.get({\n  properties: {\n    name: {\n      description: colors.magenta(&quot;Project name:&quot;)\n    }\n  }\n}, setup);\n</code></pre>\n<p>This will open a CLI asking for the name of the project, run the <code>check-install.sh</code> script, create the hostfile line for our local DNS at <code>&lt;project-name&gt;.local</code>, and log the next action that you need to take to finish installing Wordpress.</p>\n<p>Lets take a peek at our <code>check-install.sh</code> file:</p>\n<pre><code># check-install.sh\n#!/bin/bash\necho 'Check to make sure wordpress is here at all'\nif test -d ./wp/\nthen\n  echo 'yup we good'\nelse\n  echo 'nope we need that'\n  degit git@github.com:nanobox-quickstarts/nanobox-wordpress.git wp\nfi\nrsync -va --delete ./plugins/ ./wp/wp-content/plugins/\nrsync -va --delete ./theme/ ./wp/wp-content/themes/my-theme\n</code></pre>\n<p>Very similar to <code>prestart</code>! The biggest difference is the bit where we use <code>degit</code> to clone Nanobox's official Wordpress repo into our untracked <code>/wp</code> directory. Degit will only get the head files, and none of the git history. Nor will it keep the <code>.git</code> file, basically making this a super clean, super fast way to download a directory of files. It's great. The last thing this does is wipe out any themes or plugins that we don't want our need in the core files and syncs out own tracked directories to the correct places in the Wordpress core file structure.</p>\n<p>Now would be a time to talk about plugins.</p>\n<h2>What's up with plugins?</h2>\n<p>Wordpress has a million plugins. We're going to focus on some of the basic ones that almost every Wordpress project ever needs, and should honestly be part of Wordpress. Building sites without these is a pain. Here they are:</p>\n<pre><code>üìÅ /project-name\n‚Æë üìÅ plugins\n  ‚Æë üìÅ advanced-custom-fields-pro\n  ‚Æë üìÅ custom-post-types-ui\n  ‚Æë üìÅ timber-library\n  ‚Æë üìÅ wp-migrate-db-pro\n</code></pre>\n<p>There are a couple more in my repo to do things like order posts in the CMS and import CSVs. Not super necessary, so we won't talk about theme here.</p>\n<h3>Advanced Custom Fields</h3>\n<p><a href=\"https://www.advancedcustomfields.com/\">ACF</a> is a staple of Wordpress development. It lets us define new key/value pairs to extend the data model of things like posts and pages, and allows us to create a set of global variable available from anywhere. Sounds simple, surprising it's not part of Wordpress.</p>\n<h3>Custom Post Types UI</h3>\n<p><a href=\"https://wordpress.org/plugins/custom-post-type-ui/\">CPT-UI</a> creates an interface in the admin panel for creating new post types. Out of the box, Wordpress comes with <code>Posts</code> and <code>Pages</code>. CPT-UI lets us build new types like <code>Projects</code> or <code>Case Studies</code> or whatever need for our data model. Again, surprising that this  isn't just part of Wordpress. C'est la vivre.</p>\n<h3>WP Migrate DB</h3>\n<p><a href=\"https://deliciousbrains.com/wp-migrate-db-pro/\">Migrate DB</a> lets us ... migrate ... our ... DB. This gives us the ability to sync our databases across environments and get media uploads and things without needing to write magic MySQL queries while tunneled into open database ports on virtual machines. This is better. Believe me.</p>\n<h3>Timber</h3>\n<p>The <a href=\"https://www.upstatement.com/timber/\">Timber</a> library from Upstatement is the greatest thing to happen to Wordpress development, after those plugins that should just be part of Wordpress. Timber introduces the concept of <em>layout templates</em> to Wordpress. This lets us write PHP to manipulate data, and pass that data to a template file where we can write <a href=\"https://twig.symfony.com/\">Twig templates</a> rather than composing strings in PHP. Basically ...</p>\n<pre><code>&lt;?php echo $myvar ?&gt;\n</code></pre>\n<p>Turns in to:</p>\n<p>{% raw %}</p>\n<pre><code>{{ myvar }}\n</code></pre>\n<p>{% endraw %}</p>\n<p>This lets us write templates with a templating language, and write server-side business logic in a server-side programming language. Truly revolutionary.</p>\n<h2>What we talk about when we talk about Wordpress development: or, The Theme.</h2>\n<p>With all this initial work around Wordpress core, development environments, and a basic plugin ecosystem in place we can start talking about the good stuff: the theme!</p>\n<pre><code>üìÅ /project-name\n‚Æë üìÅ theme\n   ‚Æë üìÅ es6              # Source JS\n   ‚Æë üìÅ scss             # Source SCSS\n   ‚Æë üìÅ routes           # PHP route logic files\n      ‚Æë üìÑ index.php\n      ‚Æë üìÑ page.php\n      ‚Æë üìÑ post.php\n   ‚Æë üìÅ views            # Twig templates\n      ‚Æë üìÅ layouts\n      ‚Æë üìÅ pages\n      ‚Æë üìÅ partials\n   ‚Æë üìÑ functions.php    # This includes routing.\n   ‚Æë üìÑ screenshot.png   # Theme preview image.\n   ‚Æë üìÑ index.php        # Need this, but it's empty.¬Ø\\_(„ÉÑ)_/¬Ø\n</code></pre>\n<p>We won't get too deep into this, since we're getting into more conventional territory here. Basically our <code>es6</code> directory holds source JS that will get compiled into a bundle. Same with the <code>scss</code> directory, which gets compiled into css. We handle that with npm scripts in the <code>package.json</code>.</p>\n<pre><code># package.json\n{\n  ...\n  &quot;scripts&quot;: {\n    ...\n    &quot;css&quot;: &quot;node-sass ./theme/scss/style.scss theme/style.css --watch&quot;,\n    &quot;js&quot;: &quot;rollup -c -w&quot;,\n    ...\n  }\n  ...\n}\n</code></pre>\n<p>Hopefully none of this is to unusual ‚Äî if it's is I recommend reading Paul Pederson's <a href=\"http://paulcpederson.com/articles/npm-run/\">excellent article on npm scripts</a>.</p>\n<p>There is one part of this I want to touch on before moving on:</p>\n<pre><code># package.json\n{\n  ...\n  &quot;scripts&quot;: {\n    ...\n    &quot;sync:plugins&quot;: &quot;rsync -va --delete ./plugins/ ./wp/wp-content/plugins/&quot;,\n    &quot;sync:theme&quot;: &quot;rsync -va --delete ./theme/ ./wp/wp-content/themes/fuzzco&quot;,    \n    &quot;watch&quot;: &quot;rerun-script&quot;,\n    ...\n  },\n  &quot;watches&quot;: {\n    &quot;sync:plugins&quot;: &quot;plugins/**/*.*&quot;,\n    &quot;sync:theme&quot;: &quot;theme/**/*.*&quot;\n  },\n  ... \n</code></pre>\n<p>This bit sets up a watcher on our <code>theme</code> and <code>plugins</code> directory, which sync our tracked working files to the correct place in our Wordpress core file structure.</p>\n<h2>Functions, Routes, and Views</h2>\n<p>The last thing I want to touch on is the basic structure of using Timber to match routes with views.</p>\n<pre><code>/** functions.php */\nRoutes::map('/', function($params){\n  Routes::load('routes/page.php', $params, null, 200);\n});\nRoutes::map('/:page', function ($params) {\n  $page = get_page_by_path($params['page']);\n  if ($page) {\n      Routes::load('routes/page.php', $params, null, 200);\n  } else {\n      Routes::load('routes/404.php', $params, null, 404);\n  }\n});\nRoutes::map('/blog/:post', function($params){\n  Routes::load('routes/post.php', $params, null, 200);\n});\n</code></pre>\n<p>These are Timber routes defined in the <code>functions.php</code> file. This replaces the standard routing of Wordpress, and we have change the structure of the Wordpress permalinks to anything other than the default to have it work. This is documented in Timber.</p>\n<p>When our server gets a request at a route of <code>/page-name</code>, it will call the <code>page.php</code> file and pass it the params associated with the route.</p>\n<pre><code>/** page.php */\n&lt;?php\n  $context = Timber::get_context();\n  $post = new TimberPost();\n  $context['page'] = $post;\n  \n  Timber::render( array(\n    'views/pages/page-' . $post-&gt;post_name . '.twig',\n    'views/pages/page.twig'\n  ), $context );\n?&gt;\n</code></pre>\n<p>The <code>page.php</code> file assigns some variables, interacts with Wordpress to get and shape our data, and then renders the twig file associated with the page. In this case, it's going to see if there's a template that matches the name of our page, otherwise it will render the default page template.</p>\n<h2>Back to the beginning</h2>\n<p>You've built your theme! Maybe it's a simple hello world, maybe it's a heavy duty big ol' thing. Either way, it's time to deploy.</p>\n<p>You can use Nanobox to create a droplet for your server. Nanobox will give your project a name in their system, and expose the URL for the server at <code>&lt;your-project&gt;.nanoapp.io</code>. I like to use the convention <code>project-dev</code>, <code>project-stage</code>, and <code>project-prod</code>. Once you create your project in Nanobox, the hard part is over and you can let them do the heavy lifting:</p>\n<pre><code>$ nanobox deploy project-dev\n</code></pre>\n<p>Or we can map this to our NPM script:</p>\n<pre><code>$ npm run deploy:dev  \n</code></pre>\n<p>This will containerize our application, push it to our droplet, hydrate the entire thing, and serve! Now we can use Migrate DB to move our database around, and we're in business.</p>\n<h2>Putting it all together</h2>\n<p><a href=\"https://github.com/nikolaswise/nanobox-sapper-1\">The project repo</a> is a turnkey, ready to roll version of all the above. It contains all the tooling needed to get started, and if you've followed along with this guide, you should be able to get started in no time.</p>\n<p>As always, feel free to reach out to me in your venue of choice to talk about any of this ‚Äî I would be happy to help you set this up for your own Wordpress project!</p>\n"}}